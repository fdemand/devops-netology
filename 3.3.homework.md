#### 1) 
  1. #strace выводит stderror. Для удобства поиска запишем в файл вывод команды
  strace /bin/bash -c 'cd /tmp' 2> strace.out
  
  2. vagrant@vagrant:~$ grep cd ./strace.out
  execve("/bin/bash", ["/bin/bash", "-c", "cd /tmp"], 0x7ffc1e0b8fb0 /* 25 vars */) = 0
  
  execve
  Execute a program.

  int execve(const char *pathname, char *const argv[], char *const envp[])
  pathname – path to program to run
  argv – pointer to array of arguments for program
  envp – pointer to array of strings (in key=value format) for the environment
  Does not return on success, returns -1 on error.

#### 2)
  1. Скачал файл PDF wget https://files.amperka.ru/datasheets/ATmega328.pdf
  2. strace file ./test.out
  3.  stat("/home/vagrant/.magic.mgc", 0x7fff276a4e60) = -1 ENOENT (No such file or directory)
      stat("/home/vagrant/.magic", 0x7fff276a4e60) = -1 ENOENT (No such file or directory)
      openat(AT_FDCWD, "/etc/magic.mgc", O_RDONLY) = -1 ENOENT (No such file or directory)
      stat("/etc/magic", {st_mode=S_IFREG|0644, st_size=111, ...}) = 0
      openat(AT_FDCWD, "/etc/magic", O_RDONLY) = 3
      fstat(3, {st_mode=S_IFREG|0644, st_size=111, ...}) = 0
      read(3, "# Magic local data for file(1) c"..., 4096) = 111
      read(3, "", 4096)                       = 0
      close(3)                                = 0
      openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3
      
      
  Видно, что программа file ищет доп.информацию (доп. магические числа в различных директориях и не находит соответствующих файлов)
  
  4. По указанному пути /usr/share/misc/magic.mgc найден файл с базой различных типов файлов.

#### 3)
1. Создал файл питон, который пишет в файл: long_file.txt
import datetime
import time

mystr="a"*1024*1024+"\n"
with open("long_file.txt", "w") as f:
    while True:
        try:
            f.write(str(datetime.datetime.now()))
            f.write(mystr)
            f.flush()
            time.sleep(5)
        except:
            pass
            
            
            
   2. запустил: python bigfile.py &
   3. через некоторое время удалил файл long_file.txt
   4. lsof | grep deleted
   5. vagrant$sudo lsof | grep deleted
      python3 22077 root 3w REG 253,0 245373102 131132 /home/vagrant/test1/test2/long_file.txt (deleted)
      
         
      если повторять эту операцию -- видно, что размер файла растет, хотя его нет на диске (он удален)
      Соответственно размер свободного места на диске уменьшается.
      
      Также видно, что пишется в файловый дескриптор 3.
      
    6. отразим файловые дескрипторы, связанные с процессом:
       ls -lahi /proc/22077/fd
       
      
      vagrant$sudo ls -lahi /proc/22077/fd
      total 0
      256814 dr-x------ 2 root root  0 Nov 20 13:18 .
      256634 dr-xr-xr-x 9 root root  0 Nov 20 13:13 ..
      256815 lrwx------ 1 root root 64 Nov 20 13:18 0 -> /dev/pts/3
      256816 lrwx------ 1 root root 64 Nov 20 13:18 1 -> /dev/pts/3
      256817 lrwx------ 1 root root 64 Nov 20 13:18 2 -> /dev/pts/3
      256818 l-wx------ 1 root root 64 Nov 20 13:18 3 -> '/home/vagrant/test1/test2/long_file.txt (deleted)'
      
      
    7. попробовал переписать stdin для файлового дескриптора:
        echo '' > /proc/22077/fd/3
        под рутом тоже пробовал
        пробовал и через tee, как делалось в прошлом ДЗ
        echo '' | tee /proc/22077/fd/3
        
        также пробовал
        : > /home/vagrant/test1/test2/long_file.txt
        
        еще пробовал truncate -s 0 /proc/22077/fd/3
        
        
       ничего не помогает. Размер файла растет.
       
       Я так понял, что тут просто так не выкрутиться и все зависит от того как в приложении был открыт файл (с дозаписью или нет).
       
       
       Подскажите как победить проблему?
 
 #### 4)

 Зомби процессы не занимают памяти, процессорных ресурсов,IO но блокируют записи в таблице процессов, размер которой ограничен для каждого пользователя и системы в целом.
 
 Зомби-процесс существует до тех пор, пока родительский процесс не прочитает его статус с помощью системного вызова wait(), в результате чего запись в таблице процессов будет освобождена.
 
 Попробовал создать зомби:
 
 1. На первой консоли запустил ping 8.8.8.8 -c 50 > /dev/null &
 2. И тут же сделал sleep 100
 Таким образом пытался воссоздать ситуацию, когда дочерний процесс завершился, а родительский еще работает.
 Но в ps aux и в top не увидел зомби процессов.
 Возможно как-то иначе их надо плодить и проверять :)
 
 
            ├─sshd(982)─┬─sshd(15740)───sshd(15780)───bash(15781)───pstree(23074)
           │           └─sshd(23020)───sshd(23060)───bash(23061)─┬─ping(23071)
           │                                                     └─sleep(23073)
 
 
 
 #### 5) 
vagrant@vagrant:~$ sudo opensnoop-bpfcc
PID    COMM               FD ERR PATH
392    systemd-udevd      14   0 /sys/fs/cgroup/unified/system.slice/systemd-udevd.service/cgroup.procs
392    systemd-udevd      14   0 /sys/fs/cgroup/unified/system.slice/systemd-udevd.service/cgroup.threads
581    irqbalance          6   0 /proc/interrupts
581    irqbalance          6   0 /proc/stat
581    irqbalance          6   0 /proc/irq/20/smp_affinity
581    irqbalance          6   0 /proc/irq/0/smp_affinity
581    irqbalance          6   0 /proc/irq/1/smp_affinity
581    irqbalance          6   0 /proc/irq/8/smp_affinity
581    irqbalance          6   0 /proc/irq/12/smp_affinity
581    irqbalance          6   0 /proc/irq/14/smp_affinity
581    irqbalance          6   0 /proc/irq/15/smp_affinity
810    vminfo              4   0 /var/run/utmp
        
       
 #### 6)
 
 Получил syscalls через opensnoop-bpfcc, а также через strace
 
 Из вывода opensnoop-bpfcc увидел, что команда регулярно обращается к сист.вызову uname
 1048   uname               3   0 /etc/ld.so.cache
1048   uname               3   0 /lib/x86_64-linux-gnu/libc.so.6
1048   uname               3   0 /usr/lib/locale/locale-archive
 
Man по syscall в убунте не нашел

Нашел в интернете:
 
Part of the utsname information is also accessible via
/proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.
       
 vagrant@vagrant:~$ cat /proc/sys/kernel/ostype
Linux


vagrant@vagrant:~$ cat /proc/sys/kernel/version
#90-Ubuntu SMP Fri Jul 9 22:49:44 UTC 2021

vagrant@vagrant:~$ cat /proc/sys/kernel/osrelease
5.4.0-80-generic


Вывод же команды uname -a
vagrant@vagrant:~$ uname -a
Linux vagrant 5.4.0-80-generic #90-Ubuntu SMP Fri Jul 9 22:49:44 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux



       
       
