# 1) 
Команда cd является встроенной (builtin) в оболочку.
Я думаю, что ее лучше не делать отдельной программой потому, что тогда потребовалось делать постоянные манипуляции с безопасностью и 
если в системе что-то пойдет не так ( например к файлу cd не будет доступа), то трудно будет чинить систему.
Кроме того эта команда тривиальная, ее выполнение надо максимально быстрой. Соответственно надо делать встроенной.

Выполнение же отдельной команды создает отдельный процесс, а это дольше.


Кроме того, в гугле нашел: 
1. (https://www.bell-labs.com/usr/dmr/www/hist.html) комментарий Д. Ричи:
The most memorable of these became evident soon after the new system came up and apparently worked. 
In the midst of our jubilation, it was discovered that the chdir (change current directory) command had stopped working...

Я так понял, что, когда программисты вынесли cd в отдельную команду, то она не могла нормально взаимодействовать с системой.

# 2)
grep <шаблон поиска> -c <файл, в котором ищем>

# 3) init (/sbin/init)
vagrant@vagrant:~$ ps aux | head -n 2
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.0  1.1 101796 11536 ?        Ss   Nov13   0:06 /sbin/init

При этом, если посмотреть на ls /sbin/init, то можно увидеть символическая ссылка на /lib/systemd/systemd

Также об этом на говорит программа pstree -p (все дерево процессов началось от systemd)



# 4)
  Создадим 2 подключения по ssh к вирт машине.
  Командой tty для каждой сессии узнаем ее номер псевдотерминала.
  В моем слечае это сессии /dev/pts/1 и /dev/pts/2.
  Отправим содержимое несуществующего каталога с одного терминала (pts/1) на другой (pts/2):
  ls /wrong_dir 2> /dev/pts/2
  Ошибки - это поток 2

# 5)
  получится
  (cat < input_file) > output_file
  или
  cat input_file | cat output_file
  
# 6)
  можно
  будет передача с pts на tty
  1) Подключимся через ssh к запущенной ubuntu.
    
  2) В gui ubuntu нажмем ctrl+alt+f1 
    Увидим здесь номер tty1
  
  В терминале, где подлючились по ssh введем: $echo Hello > /dev/tty1.
  При этом на tty отобразится сообщение hello (даже не смотря на то, что тут окно login)

# 7)
# 7.1)
  bash 5>&1
  Создастся новый процесс bash, в котором поток 5 и объединяется с его потоком вывода 1.
# 7.1)
  При выполнении команды echo netology > /proc/$$/fd/5 в консоли отобразится netology.
  
  Для понимания почему так происходит отобразим файловые дескрипторы, связанные с данным процессом -- bash(16280)
  У меня он имеет $$ = ID процесса = 16280
  
  vagrant@vagrant:~$ ls -lai /proc/16280/fd
  total 0
  147265 dr-x------ 2 vagrant vagrant  0 Nov 17 07:15 .
  147186 dr-xr-xr-x 9 vagrant vagrant  0 Nov 17 07:07 ..
  147314 lrwx------ 1 vagrant vagrant 64 Nov 17 07:15 0 -> /dev/pts/1
  147315 lrwx------ 1 vagrant vagrant 64 Nov 17 07:15 1 -> /dev/pts/1
  147316 lrwx------ 1 vagrant vagrant 64 Nov 17 07:15 2 -> /dev/pts/1
  147321 lrwx------ 1 vagrant vagrant 64 Nov 17 07:15 255 -> /dev/pts/1
  147318 lr-x------ 1 vagrant vagrant 64 Nov 17 07:15 4 -> 'pipe:[122791]'
  147319 lrwx------ 1 vagrant vagrant 64 Nov 17 07:15 5 -> /dev/pts/1
  147320 l-wx------ 1 vagrant vagrant 64 Nov 17 07:15 9 -> 'pipe:[122794]'
  
  
  Видно, что стандартные потоки ввода, вывода, ошибок (0,1,2) заведены на терминал /dev/pts/1. 
  А также каждый поток имеет свой соответсвующий файловый дескриптор (0,1,2...)
  Предыдущей командой: bash 5>&1 мы также объединили поток 5 с потоком вывода 1 данного процесса.
  Т.о. поток(файл) 5 -> объединен с потоком вывода 1 и на правлен в терминал /dev/pts/1
  
  Соответственно команда echo netology > /proc/$$/fd/5 отправит сообщение в файловый дескриптор 5 связанный с терминалом /dev/pts/1
  и все, что будет послано на соответствующий файловый дескриптор будет приходить в консоль.


  
  

  
